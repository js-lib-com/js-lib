/**
 * X(HT)ML templates engine. A template is an X(HT)ML file that contains templates operators. An operator is declared
 * into and operates on a js.dom.Element and has an opcode and exactly one operand. The most common operator is setter
 * which takes care to set element text content or attribute. A short example may clarify:
 * 
 * <pre>
 *  // model object
 *  class Person {
 *      String description = "person description";
 *      Picture picture = new Picture("images/person.png");
 *  };
 *  
 *  // template fragment
 *  &lt;p data-text="description"&gt;&lt;/p&gt;
 *  &lt;img data-attr="src:picture;title:description;" /&gt;
 * </pre>
 * 
 * Templates engine enacts <b>data-text</b> and <b>data-attr</b> operators that set paragraph text to <b>Person</b>
 * <em>description</em>, image source to <em>picture</em> and image tooltip, i.e. its title attribute, also to
 * <em>description</em>.
 * 
 * <pre>
 *  &lt;p&gt;person description&lt;/p&gt;
 *  &lt;img src="images/person.png" title="person description" /&gt;
 * </pre>
 * 
 * Templates operators are declared using standard X(HT)ML attributes and uses next syntax:
 * 
 * <pre>
 *  operator := 'data' '-' opcode '=' '"' operand '"'
 *  opcode := see <a href="#operators-list">operators list</a>
 *  operand := propertyPath | expression
 *  propertyPath := see <a href="#object-property-path">object property path</a> 
 *  expression := evaluated by operator
 * </pre>
 * 
 * One may notice operator opcode is prefixed with <em>data-</em>. This is indeed on purpose: HTML5 allows for
 * element attributes extensions and extensions name start exactly with that prefix.
 * <p>
 * Since instruction syntax is a subset of supporting template syntax it can be kept into resulting document. This comes
 * with a big advantage: the same instructions can be used to extract model object from documents generated by templates
 * processor. This can be seen as an object oriented alternative to micro-formats. So templates processor can be used
 * for both injection and extraction of the model object into/from documents.
 * <p>
 * When processing templates, the DOM tree is traversed in synchro with model object graph. DOM is a tree of elements
 * and model is a tree of values; model tree is mapped on elements tree. This does necessarily means those trees are
 * congruent, elements tree can and usually is more complex but its overall structure resemble model tree.
 * 
 * <pre>
 *                   e1 
 *                  /               
 *     m1          e   
 *    /           / \ 
 *  m0          e0   e
 *    \           \    
 *     m2          \  
 *                  e2 
 * </pre>
 * 
 * Templates engine define a function TE: m -> e defined on model with values on elements, in other words model is
 * domain whereas elements tree is codomain. Note that TE is not surjective, that is, not for every element <b>e</b> in
 * the codomain there is an <b>m</b> in the domain such that TE(m) = e.
 * 
 * <h3 id="operators-list">Templates operators list</h3>
 * Templates engine algorithm is generic and operates on operator types, that is, groups of operators. This way adding
 * new operators does not require algorithm update. This operators list is displayed using that types hierarchy.
 * <p>
 * <table>
 * <tr>
 * <td colspan="2">1. CONDITIONAL - include or exclude DOM branches based on some condition:
 * <tr>
 * <td><b>if
 * <td>if value is empty element branch is not included in resulting document
 * <tr>
 * <td><b>ifnot
 * <td>if value is empty element branch is included in resulting document
 * <tr>
 * <td><b>case
 * <td>include element and its descendants only if conditional expression is true
 * <tr>
 * <td><b>exclude
 * <td>exclude element and its descendants from resulting document; implementation may choose to hide or completely
 * remove the branch
 * 
 * <tr>
 * <td>&nbsp;
 * <tr>
 * <td colspan="2">2. ATTRIBUTE - set specified attribute to value extracted from content:
 * <tr>
 * <td><b>attr
 * <td>set attributes values; both attributes name and value are specified into expression operand
 * <tr>
 * <td><b>id
 * <td>convenient attribute setter for element ID
 * <tr>
 * <td><b>src
 * <td>convenient attribute setter for image source
 * <tr>
 * <td><b>href
 * <td>convenient attribute setter for hyper-references; element should be an anchor or a resource link
 * <tr>
 * <td><b>title
 * <td>convenient attribute setter for tooltips
 * <tr>
 * <td><b>value
 * <td>convenient attribute setter for element value; element should be an input or textarea
 * 
 * <tr>
 * <td>&nbsp;
 * <tr>
 * <td colspan="2">3. CONTENT - operates upon element content be it text content or generated children elements:
 * <tr>
 * <td><b>object
 * <td>current element is an object with many properties and should have child elements
 * <tr>
 * <td><b>text
 * <td>set element text content
 * <tr>
 * <td><b>html
 * <td>set element inner HTML, useful for text formatted with HTML tags
 * <tr>
 * <td><b>numbering
 * <td>set element text content accordingly numbering format and item index
 * <tr>
 * <td><b>list
 * <td>current element is a list and should have a child element that is processed as list item
 * <tr>
 * <td><b>olist
 * <td>ordered variant of list operator, that is, list with numbering
 * <tr>
 * <td><b>map
 * <td>current element is a map and should have two child elements: first processed as map key and the second as value
 * <tr>
 * <td><b>omap
 * <td>ordered variant of map operator, that is, map with numbering </table>
 * <p>
 * Operators precedence is controller by their types in next order: conditional, inline, attribute, content and scope
 * operators.
 * <h3 id="object-property-path">Object property path</h3>
 * Basically templates operators inject values from content into target document. In order to identify the right piece
 * of information content is regarded as a tree of values; every value can be reached traversing the three, from node to
 * node following a unique path.
 * 
 * <pre>
 *  class Person {
 *      String name;
 *      Address address {
 *          Locality locality {
 *              String name;
 *          }
 *      }
 *  }
 * </pre>
 * 
 * In above pseudo-code person and locality names are values; locality name path is <em>.address.locality.name</em>
 * whereas person name is simple <em>.name</em>. Both exemplified paths starts with dot, meaning they are absolute
 * path. Is also possible to use relative paths, but we need a reference named <b>scope object</b> or simply <b>scope</b>.
 * So, if scope is Address, locality name path is <em>locality.name</em>; note missing dot from path start. For this
 * reason all operators receive a scope object into parameters list. Also, template scanning starts with scope root, in
 * our case Person instance; there is a scope operator used to change current scope.
 * 
 * <h3>Templates implementations</h3>
 * There are two templates engine implementations: serializer and injector. A serializer traverses DOM tree using
 * depth-first algorithm and serialize every node to a given writer. If current node contains templates operators
 * execute them. Operator execution act upon model object and result is also serialized to stream.
 * 
 * <pre>
 *  TEMPLATE -> DOM -> TP -> WRITER
 *                      ^
 *                      |
 *                   CONTENT
 * </pre>
 * 
 * An injector templates engine also traverses source DOM using depth-first but model object values are injected
 * directly into source DOM, altering it.
 * 
 * <pre>                  
 *               |<-----|       
 *               v      |  
 *  TEMPLATE -> DOM -> TP
 *                      ^
 *                      |
 *                   CONTENT   
 * </pre>
 * 
 * Currently server side implementation is a serializer and client side is an injector for obvious rationales: server
 * should send back to client documents generated on the fly, serialized on Servlet writer whereas client side should
 * update loaded DOM in order to update user interface. But both support the same operators with exactly the same
 * behavior so that documents generated on server side or on client look exactly the same, of course if generated from
 * the same template.
 * 
 * @author Iulian Rotaru
 * @version 1.0
 */
$package('js.dom.template');
